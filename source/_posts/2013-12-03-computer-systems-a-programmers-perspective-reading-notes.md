---
layout: post
title: Computer Systems A Programmer's Perspective读书笔记
date: 2013-12-03 14:13
---
2的补码表示为：
$$B2T_w(x) = -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2} x_i2^i$$
其中，w表示字长。

将有符号数x转换为无符号数：
$$
T2U_w(x) =
\begin{cases}
x + 2^w, & x < 0\\
x, & x \ge 0
\end{cases}
$$

将无符号数u转换为有符号数：
$$
U2T_w(u) =
\begin{cases}
u, & u < 2^{w-1}\\
u - 2^w, & u \ge 2^{w-1}
\end{cases}
$$

计算机中浮点数的表示：
根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：
$$
V = (-1)^s \times M \times 2^E
$$

（1）\\((-1)^s\\)表示符号位，当s=0，V为正数；当s=1，V为负数。
（2）M表示有效数字，大于等于1，小于2。
（3）\\(2^E\\)表示指数位。

举例来说，十进制的5.0，写成二进制是101.0，相当于1.01×2^2。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。
十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。

IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。
![](http://image.beekka.com/blog/201006/bg2010060601.png)

对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。
![](http://image.beekka.com/blog/201006/bg2010060602.png)

IEEE 754对有效数字M和指数E，还有一些特别规定。
前面说过，1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。

至于指数E，情况就比较复杂。

首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

然后，指数E还可以再分成三种情况：

（1）E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。

（2）E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0(当尾数是0)，以及接近于0的很小的数字(尾数不为0)。

（3）E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。

一个由C/C++编译的程序占用的内存分为以下几个部分：

1、栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
2、堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
3、全局区（静态区）（static），全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。  程序结束后由系统释放。
4、文字常量区—常量字符串就是放在这里的。程序结束后由系统释放
5、程序代码区—存放函数体的二进制代码。

```c
//main.cpp
int a = 0; //全局初始化区
char *p1; //全局未初始化区

main()
{
	int b; //栈
	char s[] = "abc"; //栈
	char *p2; //栈
	char *p3 = "123456"; //123456\\0在常量区，p3在栈上。
	static int c =0;//全局（静态）初始化区
	p1 = (char *)malloc(10);
	p2 = (char *)malloc(20);//分配得来得10和20字节的区域就在堆区。
	strcpy(p1, "123456"); //123456\\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
}
```